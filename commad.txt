git fetch --prune

const dbData = db
.createUser({
  user: "user",
  pwd: "pass",
  roles: [
    "userAdminAnyDatabase",
    "dbAdminAnyDatabase",
    "readWriteAnyDatabase",
    "restore",
    "backup",
  ],
})
.then((res) => {
  console.log("res++++", res);
})
.catch((err) => {
  console.log("err++++", err);
});


# Drop database user
[
  "dhairya.chavda_Development",
  "dhairya.chavda_Acceptance",
  "dhairya.chavda_Production",
  "comiro3128_Development",
  "comiro3128_Acceptance",
  "comiro3128_Production",
  "gafofe1427_Development",
  "gafofe1427_Acceptance",
  "gafofe1427_Production",
  "dixic32665_Development",
  "dixic32665_Acceptance",
  "dixic32665_Production",
].forEach((user) => {
  db.dropUser(user);
});

# Drop database
[
  "671b295efc2da644e74962c9_Development",
  "671b295efc2da644e74962c9_Acceptance",
  "671b295efc2da644e74962c9_Production",

  "6758071e2c27c4043cdba733_Development",
  "6758071e2c27c4043cdba733_Acceptance",
  "6758071e2c27c4043cdba733_Production",

  "67580dfe54c184da02eaf319_Development",
  "67580dfe54c184da02eaf319_Acceptance",
  "67580dfe54c184da02eaf319_Production",

  "67581e4854c184da02eaf56e_Development",
  "67581e4854c184da02eaf56e_Acceptance",
  "67581e4854c184da02eaf56e_Production",
].forEach((database) => {
  db.getMongo().getDB(database);
  print("dropping db " + database);
  db.dropDatabase();
});

mongorestore --uri="mongodb+srv://<username>:<password>@<cluster-url>/dbname" --db=test folder/*
mongodump --uri="mongodb+srv://<username>:<password>@<cluster-url>/dbname" --out=/path/to/backup  --excludeCollection xyz

sudo chown -R $USER /folder

db.getCollectionNames().forEach((cn)=> cn.includes("_revision") && db.collection(cn).drop())

# Protected branches
protected=("development" "acceptance" "master")

# Fetch latest remote changes and prune deleted branches
git fetch --prune

# Loop through local branches
for branch in $(git branch | sed 's/..//'); do
  # Skip protected branches
  if [[ " ${protected[@]} " =~ " $branch " ]]; then
    continue
  fi

  # If branch is not on remote, delete it
  if ! git show-ref --quiet refs/remotes/origin/$branch; then
    echo "Deleting local branch: $branch (not on remote)"
    git branch -D "$branch"
  fi
done

sudo usermod -aG docker $USER
newgrp docker



cd ~/Downloads

chmod +x Cursor-1.1.3-x86_64.AppImage

sudo apt update
sudo apt install libfuse2

sudo mv ~/Downloads/Cursor-1.1.3-x86_64.AppImage /opt/cursor.appimage

sudo mv ~/Downloads/cursor.png /opt/cursor.png

sudo vim /usr/share/applications/cursor.desktop
[Desktop Entry]
Name=Cursor AI IDE
Exec=/opt/cursor.appimage --no-sandbox %U
Terminal=false
Type=Application
Icon=/opt/cursor.png
StartupWMClass=Cursor
Comment=Cursor is an AI-first coding environment.
Categories=Development;

sudo chmod +x /usr/share/applications/cursor.desktop


tar file install
tar -xzf studio-3t-community-edition-linux-x64.tar.gz
sudo mv studio-3t-YYYY.MM.DD /opt/studio-3t
cd /opt/studio-3t

sudo vim /usr/share/applications/studio-3t.desktop
[Desktop Entry]
Name=Studio 3T
Comment=MongoDB GUI
Exec=/opt/studio-3t/studio-3t.sh
Icon=/opt/studio-3t/studio-3t.png  # Adjust this path if your icon is elsewhere
Terminal=false
Type=Application
Categories=Development;Database;

chmod +x /usr/share/applications/studio-3t.desktop



db.adminCommand({ listDatabases: 1, nameOnly: true }).databases.forEach(function(dbs) {
    if (/_Development/.test(dbs.name)) {
        print("Found database: " + dbs.name);
        db = db.getSiblingDB(dbs.name);
        db.nox_presets.drop();
        print("Collection 'nox_presets' dropped in " + dbs.name);
    }
});


db.adminCommand({ listDatabases: 1, nameOnly: true }).databases.forEach(function (dbs) {
  if (/_Acceptance/.test(dbs.name)) {
    print("Processing database: " + dbs.name);
    var currentDb = db.getSiblingDB(dbs.name);
    var collection = currentDb.getCollection("nox_presets");

    var deleteResult = collection.deleteMany({ userId: { $exists: false } });
    print(`Deleted ${deleteResult.deletedCount} docs without userId in ${dbs.name}`);

    var cursor = collection.find({
      userId: { $exists: true },
      "layout_query.tabular.fields.field_name": { $exists: true },
    });

    cursor.forEach(function (doc) {
      try {
        let fieldNamesOnly = [];
        const fields = (((doc || {}).layout_query || {}).tabular || {}).fields || [];

        fields.forEach((field) => {
          if (field && typeof field === "object" && "field_name" in field) {
            fieldNamesOnly.push(field.field_name);
          }
        });

        collection.updateOne(
          { _id: doc._id },
          { $set: { "layout_query.tabular.fields": fieldNamesOnly } }
        );
      } catch (e) {
        print(`Error updating doc with _id=${doc._id}: ${e}`);
      }
    });

====================================================================================================================================================================================
# Get collection which dose not have data
db.getCollectionNames().forEach(function(collectionName) {
  if (db.getCollection(collectionName).countDocuments({}) === 0) {
    print(collectionName);
  }
});

====================================================================================================================================================================================
#!/bin/bash

# Script to perform mongodump while excluding specified collections.

DATABASE_NAME="my_database" # Name of the database to back up
DATABASE_URI="mongodb://localhost:27017/${DATABASE_NAME}" # MongoDB URI

EXCLUDE_COLLECTIONS=( # List of collections to exclude from the dump
    "collection_to_exclude_1"
    "collection_to_exclude_2"
    "collection_to_exclude_3"
    "another_collection_to_exclude"
)

OUTPUT_DIRECTORY="mongo_backup_$(date +%F_%H-%M-%S)" # Output directory for the backup

if ! command -v mongodump >/dev/null 2>&1; then # Check if mongodump is installed
    echo "Error: mongodump is not installed or not in your PATH."
    exit 1
fi

if [ -z "$DATABASE_NAME" ]; then # Check if database name is set
    echo "Error: DATABASE_NAME is not set."
    exit 1
fi

DUMP_COMMAND=(mongodump --uri="${DATABASE_URI}" --db="${DATABASE_NAME}" --out="${OUTPUT_DIRECTORY}") # Build mongodump command

for collection in "${EXCLUDE_COLLECTIONS[@]}"; do # Add excludeCollection options
    DUMP_COMMAND+=(--excludeCollection="${collection}")
done

echo "Executing the following command:" # Show the command to be executed
echo "${DUMP_COMMAND[@]}"
echo "----------------------------------------"

"${DUMP_COMMAND[@]}" # Run the mongodump command

if [ $? -eq 0 ]; then # Check if mongodump succeeded
    echo "----------------------------------------"
    echo "mongodump completed successfully!"
    echo "Backup files are located in: ${OUTPUT_DIRECTORY}"
else
    echo "----------------------------------------"
    echo "Error: mongodump failed. Please check the output above for details."
fi
====================================================================================================================================================================================
#!/bin/bash

# --- Configuration ---
DATABASE_NAME="my_database"
DUMP_DATABASE_NAME="my_dumped_database"
DATABASE_URI="mongodb://localhost:27017/my_database"
INPUT_DUMP_PATH="mongo_backup_2025-08-04_11-21-30"

INCLUDE_COLLECTIONS=(
    #"users"
    #"products"
    #"orders"
)

EXCLUDE_COLLECTIONS=(
    "collection_to_exclude_1"
    "collection_to_exclude_2"
    "collection_to_exclude_3"
)

# --- Script Logic ---
echo "Starting flexible mongorestore for database: ${DATABASE_NAME}."
echo "----------------------------------------"

# Check for mutually exclusive include/exclude
if [ ${#INCLUDE_COLLECTIONS[@]} -gt 0 ] && [ ${#EXCLUDE_COLLECTIONS[@]} -gt 0 ]; then
    echo "Error: Both INCLUDE_COLLECTIONS and EXCLUDE_COLLECTIONS are populated."
    echo "Please use only one list at a time to avoid conflicts."
    exit 1
fi

# Check if the dump path exists (should check for DUMP_DATABASE_NAME, not DATABASE_NAME)
if [ ! -d "${INPUT_DUMP_PATH}/${DUMP_DATABASE_NAME}" ]; then
    echo "Error: The dump directory '${INPUT_DUMP_PATH}/${DUMP_DATABASE_NAME}' does not exist."
    echo "Please check your INPUT_DUMP_PATH and DUMP_DATABASE_NAME variables and try again."
    exit 1
fi

# Build mongorestore command
RESTORE_COMMAND="mongorestore --uri=${DATABASE_URI} --db=${DATABASE_NAME} --drop ${INPUT_DUMP_PATH}/${DUMP_DATABASE_NAME}"

if [ ${#INCLUDE_COLLECTIONS[@]} -gt 0 ]; then
    echo "Restoring selected collections..."
    for collection in "${INCLUDE_COLLECTIONS[@]}"; do
        RESTORE_COMMAND+=" --nsInclude=${DUMP_DATABASE_NAME}.${collection}"
    done
elif [ ${#EXCLUDE_COLLECTIONS[@]} -gt 0 ]; then
    echo "Restoring all collections except the excluded ones..."
    for collection in "${EXCLUDE_COLLECTIONS[@]}"; do
        RESTORE_COMMAND+=" --nsExclude=${DUMP_DATABASE_NAME}.${collection}"
    done
else
    echo "No include or exclude collections specified. Restoring the entire database."
fi

echo "Executing the following command:"
echo "${RESTORE_COMMAND}"
echo "----------------------------------------"

eval "${RESTORE_COMMAND}"

if [ $? -eq 0 ]; then
    echo "----------------------------------------"
    echo "mongorestore completed successfully!"
else
    echo "----------------------------------------"
    echo "Error: mongorestore failed. Please check the output above for details."
fi

=====================================================================================================================================================================================================
## ðŸ“‹ **MongoDB Connection & Activity Monitoring Commands**

| Purpose                                                            | Command / Snippet                                                                                |
| ------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------ |
| ðŸ”„ Get total connection stats                                      | `db.serverStatus().connections`                                                                  |
| ðŸ“ˆ View connection usage over time (Atlas UI)                      | Atlas â†’ Cluster â†’ **Metrics** â†’ "Connections"                                                    |
| ðŸ§  Get all current operations (active + idle)                      | `db.currentOp(true).inprog`                                                                      |
| ðŸ” Filter only ops with active client connections                  | `db.currentOp(true).inprog.filter(op => op.client)`                                              |
| âœ… Show only **active operations**                                  | `db.currentOp(true).inprog.filter(op => op.active)`                                              |
| ðŸ’¤ Show only **idle connections** (open sockets with no operation) | `db.currentOp(true).inprog.filter(op => op.client && !op.op)`                                    |
| ðŸ“Œ Show ops by specific user                                       | `db.currentOp(true).inprog.filter(op => op.authenticatedUsers?.[0]?.user === "yourUser")`        |
| ðŸŒ Group connections by IP                                         | See [IP Grouping Script](#group-by-ip) below                                                     |
| ðŸ‘¤ Group connections by user + db                                  | See [User+DB Grouping Script](#group-by-user--db)                                                |
| âŒ Kill a specific op (active only)                                 | `db.killOp(opid)`                                                                                |
| âš ï¸ Attempt to kill all active ops (not idle ones)                  | `db.currentOp(true).inprog.filter(op => op.active && op.opid).forEach(op => db.killOp(op.opid))` |
| ðŸ”Ž List authenticated users with open ops                          | `db.currentOp(true).inprog.map(op => op.authenticatedUsers)`                                     |

---

## ðŸ§© Group by IP

```js
const byIP = db.currentOp(true).inprog
  .filter(op => op.client)
  .map(op => op.client.split(':')[0])
  .reduce((acc, ip) => {
    acc[ip] = (acc[ip] || 0) + 1;
    return acc;
  }, {});
console.log(byIP);
```

---

## ðŸ§‘â€ðŸ’» Group by User + DB

```js
const byUserDb = db.currentOp(true).inprog
  .filter(op => op.authenticatedUsers?.length)
  .map(op => {
    const u = op.authenticatedUsers[0];
    return `${u.user}@${u.db}`;
  })
  .reduce((acc, key) => {
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});
console.log(byUserDb);
```

---

## ðŸ“Š Total Active vs Inactive Count

```js
const ops = db.currentOp(true).inprog;
const stats = {
  total: ops.length,
  withClient: ops.filter(op => op.client).length,
  active: ops.filter(op => op.active).length,
  idle: ops.filter(op => op.client && !op.op).length,
};
console.log(stats);
```

---

## ðŸ“Œ Tip: Monitor from Application (Node.js)

You can also monitor active connections from your **app** if using `mongoose`:

```js
mongoose.connection.on('connected', () => console.log('MongoDB connected'));
mongoose.connection.on('disconnected', () => console.log('MongoDB disconnected'));
```

---

## âœ… Summary of Most Useful Commands

| Task                   | Command                                 |
| ---------------------- | --------------------------------------- |
| Total connections      | `db.serverStatus().connections`         |
| All current operations | `db.currentOp(true).inprog`             |
| Active queries         | `...filter(op => op.active)`            |
| Idle sockets           | `...filter(op => op.client && !op.op)`  |
| Group by IP            | See [IP grouping script](#ip-group)     |
| Group by user          | See [User grouping script](#user-group) |
| Kill operation         | `db.killOp(opid)`                       |

=====================================================================================================================================================================================================
