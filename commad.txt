git fetch --prune

const dbData = db
.createUser({
  user: "user",
  pwd: "pass",
  roles: [
    "userAdminAnyDatabase",
    "dbAdminAnyDatabase",
    "readWriteAnyDatabase",
    "restore",
    "backup",
  ],
})
.then((res) => {
  console.log("res++++", res);
})
.catch((err) => {
  console.log("err++++", err);
});


# Drop database user
[
  "dhairya.chavda_Development",
  "dhairya.chavda_Acceptance",
  "dhairya.chavda_Production",
  "comiro3128_Development",
  "comiro3128_Acceptance",
  "comiro3128_Production",
  "gafofe1427_Development",
  "gafofe1427_Acceptance",
  "gafofe1427_Production",
  "dixic32665_Development",
  "dixic32665_Acceptance",
  "dixic32665_Production",
].forEach((user) => {
  db.dropUser(user);
});

# Drop database
[
  "671b295efc2da644e74962c9_Development",
  "671b295efc2da644e74962c9_Acceptance",
  "671b295efc2da644e74962c9_Production",

  "6758071e2c27c4043cdba733_Development",
  "6758071e2c27c4043cdba733_Acceptance",
  "6758071e2c27c4043cdba733_Production",

  "67580dfe54c184da02eaf319_Development",
  "67580dfe54c184da02eaf319_Acceptance",
  "67580dfe54c184da02eaf319_Production",

  "67581e4854c184da02eaf56e_Development",
  "67581e4854c184da02eaf56e_Acceptance",
  "67581e4854c184da02eaf56e_Production",
].forEach((database) => {
  db.getMongo().getDB(database);
  print("dropping db " + database);
  db.dropDatabase();
});

mongorestore --uri="mongodb+srv://<username>:<password>@<cluster-url>/dbname" --db=test folder/*
mongodump --uri="mongodb+srv://<username>:<password>@<cluster-url>/dbname" --out=/path/to/backup  --excludeCollection xyz

sudo chown -R $USER /folder

db.getCollectionNames().forEach((cn)=> cn.includes("_revision") && db.collection(cn).drop())

# Protected branches
protected=("development" "acceptance" "master")

# Fetch latest remote changes and prune deleted branches
git fetch --prune

# Loop through local branches
for branch in $(git branch | sed 's/..//'); do
  # Skip protected branches
  if [[ " ${protected[@]} " =~ " $branch " ]]; then
    continue
  fi

  # If branch is not on remote, delete it
  if ! git show-ref --quiet refs/remotes/origin/$branch; then
    echo "Deleting local branch: $branch (not on remote)"
    git branch -D "$branch"
  fi
done

sudo usermod -aG docker $USER
newgrp docker



cd ~/Downloads

chmod +x Cursor-1.1.3-x86_64.AppImage

sudo apt update
sudo apt install libfuse2

sudo mv ~/Downloads/Cursor-1.1.3-x86_64.AppImage /opt/cursor.appimage

sudo mv ~/Downloads/cursor.png /opt/cursor.png

sudo vim /usr/share/applications/cursor.desktop
[Desktop Entry]
Name=Cursor AI IDE
Exec=/opt/cursor.appimage --no-sandbox %U
Terminal=false
Type=Application
Icon=/opt/cursor.png
StartupWMClass=Cursor
Comment=Cursor is an AI-first coding environment.
Categories=Development;

sudo chmod +x /usr/share/applications/cursor.desktop


tar file install
tar -xzf studio-3t-community-edition-linux-x64.tar.gz
sudo mv studio-3t-YYYY.MM.DD /opt/studio-3t
cd /opt/studio-3t

sudo vim /usr/share/applications/studio-3t.desktop
[Desktop Entry]
Name=Studio 3T
Comment=MongoDB GUI
Exec=/opt/studio-3t/studio-3t.sh
Icon=/opt/studio-3t/studio-3t.png  # Adjust this path if your icon is elsewhere
Terminal=false
Type=Application
Categories=Development;Database;

chmod +x /usr/share/applications/studio-3t.desktop



db.adminCommand({ listDatabases: 1, nameOnly: true }).databases.forEach(function(dbs) {
    if (/_Development/.test(dbs.name)) {
        print("Found database: " + dbs.name);
        db = db.getSiblingDB(dbs.name);
        db.nox_presets.drop();
        print("Collection 'nox_presets' dropped in " + dbs.name);
    }
});


db.adminCommand({ listDatabases: 1, nameOnly: true }).databases.forEach(function (dbs) {
  if (/_Acceptance/.test(dbs.name)) {
    print("Processing database: " + dbs.name);
    var currentDb = db.getSiblingDB(dbs.name);
    var collection = currentDb.getCollection("nox_presets");

    var deleteResult = collection.deleteMany({ userId: { $exists: false } });
    print(`Deleted ${deleteResult.deletedCount} docs without userId in ${dbs.name}`);

    var cursor = collection.find({
      userId: { $exists: true },
      "layout_query.tabular.fields.field_name": { $exists: true },
    });

    cursor.forEach(function (doc) {
      try {
        let fieldNamesOnly = [];
        const fields = (((doc || {}).layout_query || {}).tabular || {}).fields || [];

        fields.forEach((field) => {
          if (field && typeof field === "object" && "field_name" in field) {
            fieldNamesOnly.push(field.field_name);
          }
        });

        collection.updateOne(
          { _id: doc._id },
          { $set: { "layout_query.tabular.fields": fieldNamesOnly } }
        );
      } catch (e) {
        print(`Error updating doc with _id=${doc._id}: ${e}`);
      }
    });

====================================================================================================================================================================================
#!/bin/bash

# ==============================================================================
# This script performs a mongodump, excluding a list of specified collections.
#
# How to use:
# 1. Update the 'DATABASE_NAME' variable with your database name.
# 2. Add the names of the collections you want to exclude to the
#    'EXCLUDE_COLLECTIONS' array.
# 3. Save the file (e.g., as mongodump_exclude.sh).
# 4. Make the script executable: chmod +x mongodump_exclude.sh
# 5. Run the script: ./mongodump_exclude.sh
# ==============================================================================

# --- Configuration ---
# The name of the database you want to back up.
DATABASE_NAME="my_database"
DATABASE_URI="mongodb://localhost:27017/${DATABASE_NAME}"

# An array of collection names to exclude from the dump.
# Add or remove collections from this list as needed.
EXCLUDE_COLLECTIONS=(
    "collection_to_exclude_1"
    "collection_to_exclude_2"
    "collection_to_exclude_3"
    "another_collection_to_exclude"
)

# Optional: Specify the output directory for the dump.
# If not specified, it will create a 'mongo_backup_<date>' directory in the current location.
OUTPUT_DIRECTORY="mongo_backup_$(date +%F_%H-%M-%S)"

# --- Script Logic ---

# Check if mongodump is installed
if ! command -v mongodump >/dev/null 2>&1; then
    echo "Error: mongodump is not installed or not in your PATH."
    exit 1
fi

# Check if DATABASE_NAME is set
if [ -z "$DATABASE_NAME" ]; then
    echo "Error: DATABASE_NAME is not set."
    exit 1
fi

# Build the mongodump command
DUMP_COMMAND=(mongodump --uri="${DATABASE_URI}" --db="${DATABASE_NAME}" --out="${OUTPUT_DIRECTORY}")

# Append --excludeCollection for each collection to exclude
for collection in "${EXCLUDE_COLLECTIONS[@]}"; do
    DUMP_COMMAND+=(--excludeCollection="${collection}")
done

# Echo the final command to the console for verification.
echo "Executing the following command:"
echo "${DUMP_COMMAND[@]}"
echo "----------------------------------------"

# Execute the constructed command.
"${DUMP_COMMAND[@]}"

# --- Post-Execution ---
if [ $? -eq 0 ]; then
    echo "----------------------------------------"
    echo "mongodump completed successfully!"
    echo "Backup files are located in: ${OUTPUT_DIRECTORY}"
else
    echo "----------------------------------------"
    echo "Error: mongodump failed. Please check the output above for details."
fi


    print("Finished processing: " + dbs.name);
  }
});
====================================================================================================================================================================================
#!/bin/bash

# ==============================================================================
# This script performs a flexible mongorestore operation.
# It can either restore a selected list of collections OR restore all
# collections EXCEPT for a specified list of excluded collections.
#
# How to use:
# 1. Update the 'DATABASE_NAME' and 'INPUT_DUMP_PATH' variables.
# 2. Populate EITHER the 'INCLUDE_COLLECTIONS' array OR the 'EXCLUDE_COLLECTIONS' array.
#    DO NOT populate both at the same time. The script will exit with an error if you do.
# 3. Save the file (e.g., as mongorestore.sh).
# 4. Make the script executable: chmod +x mongorestore.sh
# 5. Run the script: ./mongorestore.sh
#
# Note: The '--drop' flag is included by default to drop existing collections
#       before restoring. You can remove it if you prefer to merge data.
# ==============================================================================

# --- Configuration ---
DATABASE_NAME="my_database"
DUMP_DATABASE_NAME="my_dumped_database"
DATABASE_URI="mongodb://localhost:27017/my_database"
INPUT_DUMP_PATH="mongo_backup_2025-08-04_11-21-30"

INCLUDE_COLLECTIONS=(
    #"users"
    #"products"
    #"orders"
)

EXCLUDE_COLLECTIONS=(
    "collection_to_exclude_1"
    "collection_to_exclude_2"
    "collection_to_exclude_3"
)

# --- Script Logic ---
echo "Starting flexible mongorestore for database: ${DATABASE_NAME}."
echo "----------------------------------------"

# Check for mutually exclusive include/exclude
if [ ${#INCLUDE_COLLECTIONS[@]} -gt 0 ] && [ ${#EXCLUDE_COLLECTIONS[@]} -gt 0 ]; then
    echo "Error: Both INCLUDE_COLLECTIONS and EXCLUDE_COLLECTIONS are populated."
    echo "Please use only one list at a time to avoid conflicts."
    exit 1
fi

# Check if the dump path exists (should check for DUMP_DATABASE_NAME, not DATABASE_NAME)
if [ ! -d "${INPUT_DUMP_PATH}/${DUMP_DATABASE_NAME}" ]; then
    echo "Error: The dump directory '${INPUT_DUMP_PATH}/${DUMP_DATABASE_NAME}' does not exist."
    echo "Please check your INPUT_DUMP_PATH and DUMP_DATABASE_NAME variables and try again."
    exit 1
fi

# Build mongorestore command
RESTORE_COMMAND="mongorestore --uri=${DATABASE_URI} --db=${DATABASE_NAME} --drop ${INPUT_DUMP_PATH}/${DUMP_DATABASE_NAME}"

if [ ${#INCLUDE_COLLECTIONS[@]} -gt 0 ]; then
    echo "Restoring selected collections..."
    for collection in "${INCLUDE_COLLECTIONS[@]}"; do
        RESTORE_COMMAND+=" --nsInclude=${DUMP_DATABASE_NAME}.${collection}"
    done
elif [ ${#EXCLUDE_COLLECTIONS[@]} -gt 0 ]; then
    echo "Restoring all collections except the excluded ones..."
    for collection in "${EXCLUDE_COLLECTIONS[@]}"; do
        RESTORE_COMMAND+=" --nsExclude=${DUMP_DATABASE_NAME}.${collection}"
    done
else
    echo "No include or exclude collections specified. Restoring the entire database."
fi

echo "Executing the following command:"
echo "${RESTORE_COMMAND}"
echo "----------------------------------------"

eval "${RESTORE_COMMAND}"

if [ $? -eq 0 ]; then
    echo "----------------------------------------"
    echo "mongorestore completed successfully!"
else
    echo "----------------------------------------"
    echo "Error: mongorestore failed. Please check the output above for details."
fi


